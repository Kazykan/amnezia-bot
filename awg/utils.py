import base64
import json
import os
import re
from typing import Dict
import aiohttp
import logging
import aiofiles
import ipaddress
from datetime import datetime, timedelta, timezone

from aiogram.types import User
from service.base_model import ActiveClient, Config, PeerData, UserData
from settings import CACHE_TTL, ISP_CACHE_FILE, WG_CONFIG_FILE

logger = logging.getLogger(__name__)


def parse_relative_time(relative_str: str) -> datetime:
    if not isinstance(relative_str, str) or not relative_str.strip():
        logger.error(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π relative_str: {relative_str}")
        return datetime.now(timezone.utc)  # –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    try:
        relative_str = relative_str.lower().replace(" ago", "")
        delta = 0
        for part in relative_str.split(", "):
            num, unit = part.split()
            num = int(num)
            if "minute" in unit:
                delta += num * 60
            elif "hour" in unit:
                delta += num * 3600
            elif "day" in unit:
                delta += num * 86400
            elif "week" in unit:
                delta += num * 604800
            elif "month" in unit:
                delta += num * 2592000
        return datetime.now(timezone.utc) - timedelta(seconds=delta)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ parse_relative_time: {str(e)}")
        return datetime.now(timezone.utc)  # –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é


def parse_transfer(transfer_str):
    if not isinstance(transfer_str, str) or not transfer_str.strip():
        logger.error(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π transfer_str: {transfer_str}")
        return 0, 0  # –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    try:
        incoming, outgoing = re.split(r"[/,]", transfer_str)[:2]
        size_map = {
            "B": 1,
            "KB": 10**3,
            "KiB": 1024,
            "MB": 10**6,
            "MiB": 1024**2,
            "GB": 10**9,
            "GiB": 1024**3,
        }
        incoming_bytes = outgoing_bytes = 0
        for unit, multiplier in size_map.items():
            if unit in incoming:
                match = re.match(r"([\d.]+)", incoming)
                if match:
                    incoming_bytes = float(match.group(0)) * multiplier
            if unit in outgoing:
                match = re.match(r"([\d.]+)", outgoing)
                if match:
                    outgoing_bytes = float(match.group(0)) * multiplier
        return incoming_bytes, outgoing_bytes
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ parse_transfer: {str(e)}")
        return 0, 0  # –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é


isp_cache = {}


def get_interface_name():
    return os.path.basename(WG_CONFIG_FILE).split(".")[0]


async def load_isp_cache():
    global isp_cache
    if os.path.exists(ISP_CACHE_FILE):
        async with aiofiles.open(ISP_CACHE_FILE, "r") as f:
            isp_cache = json.loads(await f.read())


async def save_isp_cache():
    async with aiofiles.open(ISP_CACHE_FILE, "w") as f:
        await f.write(json.dumps(isp_cache))


async def get_isp_info(ip: str) -> str:
    now = datetime.now(timezone.utc).timestamp()
    if ip in isp_cache and (now - isp_cache[ip]["timestamp"]) < CACHE_TTL:
        return isp_cache[ip]["isp"]

    try:
        if ipaddress.ip_address(ip).is_private:
            return "Private Range"
    except:
        return "Invalid IP"

    async with aiohttp.ClientSession() as session:
        async with session.get(f"http://ip-api.com/json/{ip}?fields=isp") as resp:
            if resp.status == 200:
                data = await resp.json()
                isp = data.get("isp", "Unknown ISP")
                isp_cache[ip] = {"isp": isp, "timestamp": now}
                await save_isp_cache()
                return isp
    return "Unknown ISP"


def get_short_name(user: User) -> str:
    """–§–æ—Ä–º–∏—Ä—É–µ—Ç –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: username –∏–ª–∏ –∏–º—è + —Ñ–∞–º–∏–ª–∏—è (–æ–±—Ä–µ–∑–∞–µ—Ç—Å—è –¥–æ 30 —Å–∏–º–≤–æ–ª–æ–≤)."""
    if user.username:
        name = f"@{user.username}"
    else:
        name_parts = filter(None, [user.first_name, user.last_name])
        name = " ".join(name_parts)
    return name[:10]


def generate_deactivate_presharekey():
    """ "–ü–æ–ª—É—á–∞–µ–º –º—É—Å–æ—Ä–Ω—É—é —Å—Ç—Ä–æ–∫—É"""
    fixed_prefix = b"Deactivate"  # 10 –±–∞–π—Ç
    total_bytes = 32  # WireGuard —Ç—Ä–µ–±—É–µ—Ç —Ä–æ–≤–Ω–æ 32 –±–∞–π—Ç–∞
    random_part_length = total_bytes - len(fixed_prefix)

    if random_part_length < 0:
        raise ValueError("Prefix is too long for a 32-byte key")

    random_part = os.urandom(random_part_length)
    full_bytes = fixed_prefix + random_part

    # –ó–∞–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –≤ Base64 –∏ —É–±—Ä–∞—Ç—å –ø–∞–¥–¥–∏–Ω–≥–∏ "="
    base64_key = base64.b64encode(full_bytes).decode()

    if len(base64_key) != 44:
        raise ValueError(
            f"Resulting Base64 key is not 44 characters long: {len(base64_key)}"
        )

    return base64_key


def get_profile_text(user: UserData):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —É—á—ë—Ç–æ–º —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –∏ –ø—Ä–æ–±–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞.
    """
    trial_text = ""

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏
    if user.is_unlimited:
        subscription_text = "‚ôæÔ∏è –ë–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è"

    elif user.end_date:
        try:
            end_date_obj = datetime.strptime(user.end_date, "%Y-%m-%d")
            end_date_str = end_date_obj.strftime("%d.%m.%Y")
        except Exception:
            end_date_obj = None
            end_date_str = user.end_date  # –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å

        if end_date_obj and end_date_obj < datetime.now():
            subscription_text = f"‚ùå –ü–æ–¥–ø–∏—Å–∫–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å {end_date_str}"
        else:
            subscription_text = f"üìÖ –ê–∫—Ç–∏–≤–Ω–∞ –¥–æ {end_date_str}"

    else:
        subscription_text = "‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏"
        trial_text = (
            f"üß™ –ü—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥: {'–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω' if user.has_used_trial else '–¥–æ—Å—Ç—É–ø–µ–Ω'}"
        )

    # –°–±–æ—Ä–∫–∞ —Ç–µ–∫—Å—Ç–∞ –ø—Ä–æ—Ñ–∏–ª—è
    profile_text = (
        f"üë§ *–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å*\n\n"
        f"üÜî ID: `{user.telegram_id}`\n"
        f"üë• –ò–º—è: *{user.name}*\n"
        f"{subscription_text}\n"
    )

    if trial_text:
        profile_text += f"{trial_text}"

    return profile_text


def generate_config_text(config: Config) -> str:
    """–§–æ—Ä–º–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç VPN-–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ WireGuard."""
    lines = ["[Interface]"]
    lines.append(f"Address = {config.address}")
    if config.dns:
        lines.append(f"DNS = {config.dns}")
    lines.append(f"PrivateKey = {config.private_key}")

    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    for field in ["jc", "jmin", "jmax", "s1", "s2", "h1", "h2", "h3", "h4"]:
        value = getattr(config, field)
        if value is not None:
            lines.append(f"{field.upper()} = {value}")

    lines.append("[Peer]")
    lines.append(f"PublicKey = {config.public_key}")
    if config.preshared_key:
        lines.append(f"PresharedKey = {config.preshared_key}")
    if config.allowed_ips:
        lines.append(f"AllowedIPs = {config.allowed_ips}")
    if config.endpoint:
        lines.append(f"Endpoint = {config.endpoint}")
    if config.persistent_keepalive:
        lines.append(f"PersistentKeepalive = {config.persistent_keepalive}")

    return "\n".join(lines)


def get_vpn_caption(user_id: int) -> str:
    return (
        f"–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è {user_id}:\n"
        f"AmneziaVPN:\n"
        f"üì± [App Store](https://apps.apple.com/ru/app/amneziawg/id6478942365)\n"
        f"ü§ñ [Google Play](https://play.google.com/store/apps/details?id=org.amnezia.vpn&hl=ru)\n"
        f"üíª [GitHub](https://github.com/amnezia-vpn/amnezia-client)\n"
    )


def get_welcome_caption() -> str:
    return (
        "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ *Rufat –ë–æ—Ç!*\n\n"
        "‚ö° **–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ.** üîê **–ü–æ–ª–Ω–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å.** üí∏ **–í—Å–µ–≥–æ –∑–∞ 80‚ÇΩ –≤ –º–µ—Å—è—Ü.**\n\n"
        "–≠—Ç–æ –¥–æ—Å—Ç—É–ø–Ω–µ–µ —á–∞—à–∫–∏ –∫–æ—Ñ–µ, –Ω–æ –Ω–µ—Å—Ä–∞–≤–Ω–∏–º–æ –ø–æ–ª–µ–∑–Ω–µ–µ.\n"
        '–ù–∞–∂–º–∏ **"–ü–æ–¥–∫–ª—é—á–∏—Ç—å"** –∏ –Ω–∞—Å–ª–∞–∂–¥–∞–π—Å—è –±—ã—Å—Ç—Ä—ã–º –∏ –∑–∞—â–∏—â—ë–Ω–Ω—ã–º –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–æ–º —É–∂–µ —Å–µ–π—á–∞—Å! üöÄ\n\n'
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
    )


def get_instructions_text() -> str:
    return (
        "–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å, —Å–Ω–∞—á–∞–ª–∞ —Å–∫–∞—á–∞–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –∑–∞—Ç–µ–º —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –µ–≥–æ. –ü–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –≤–∞—à–µ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ø–æ–¥—Ä–æ–±–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏.\n\n"
        "–°—Å—ã–ª–∫–∏ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è AmneziaVPN:\n"
        "üì± –ï—Å–ª–∏ —É –≤–∞—Å iPhone –∏–ª–∏ iPad ‚Äì —Å–∫–∞—á–∞–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–¥–µ—Å—å: [App Store](https://apps.apple.com/ru/app/amneziawg/id6478942365)\n\n"
        "ü§ñ –ï—Å–ª–∏ —É –≤–∞—Å Android ‚Äì —Å–∫–∞—á–∞–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–¥–µ—Å—å: [Google Play](https://play.google.com/store/apps/details?id=org.amnezia.vpn&hl=ru)\n\n"
        "–ü–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Å–≤–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å, –∫–∞–∫ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.\n\n"
        "‚ÑπÔ∏è –ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –∏–ª–∏ –æ—Å—Ç–∞–ª–∏—Å—å –≤–æ–ø—Ä–æ—Å—ã ‚Äî –Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ: [@Kazykan] (https://t.me/Kazykan)"
    )
